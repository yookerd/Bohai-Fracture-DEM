; Filename: flt.FIS
;
; PURPOSE:  These functions used when attempting to eliminate
;           "floaters" (particles with less than [flt_def] contacts)
;           from the initial packed assembly.
;
; Itasca Consulting Group, Inc.
; ===================================================================
;
; ===================================================================
; PUBLIC FUNCTIONS
; ===================================================================
;
def flt_eliminate
;
; ----- Entry-level call to invoke floater-reduction algorithm.
;
; INPUT: flt_def    - balls with < [flt_def] contacts are "floaters"
;        flt_remain - proportion of total balls that can be floaters
;
    _debug = 1  ; always dump run-tracking info. to screen
    pc_zap_floaters
end

; ===================================================================
def pc_zap_floaters
;
; ----- Eliminate the floaters in the assembly.
;
;    CAUTION:  Friction will be set to zero! ... re-specify at end
;              Ball color indices will be changed!
;              All balls will be freed
;              Set bonds immediately after exit.
;
; Can monitor via internal variables:
;    _pc_n_float  ; Number of floaters
;    _pc_n_active ; Number of floaters being adjusted
;    _pc_max_act_force    ; Max floater force
;    _pc_av_contact_force ; Average contact force
;
; INPUT: flt_remain - proportion of total balls that can be floaters
;        flt_def    - balls with < [flt_def] contacts are "floaters"
;
;--- parameters ---
    _pc_r_mult = 1.3  ; Initial radius multiplier
    _pc_f_tol  = 0.1  ; Fraction of mean contact force to aim for
    _pc_ncut   = flt_def  ; Number contacts to qualify as a floater
    _pc_relax  = 1.5  ; ... account for Kn in series
    _pc_hyst   = 0.9  ; Hysteresis factor on force reduction
;------------------
    _pc_remain = int(flt_remain * ball.num)
;

    io.out('_pc_n_float          = ' + string(_pc_n_float         )) ; Number of floaters (internal to this alg.)
    io.out('_pc_n_active         = ' + string(_pc_n_active        )) ; Number of floaters being adjusted
    io.out('_pc_max_act_force    = ' + string(_pc_max_act_force   )) ; Max floater force
    io.out('_pc_av_contact_force = ' + string(_pc_av_contact_force)) ; Average contact force
    
    ;command
    ;  history reset             ; remove _tm_isostr from history list,
    ;                            ;   it should not be being sampled now
    ;  hist _pc_n_float          ; Number of floaters (internal to this alg.)
    ;  hist _pc_n_active         ; Number of floaters being adjusted
    ;  hist _pc_max_act_force    ; Max floater force
    ;  hist _pc_av_contact_force ; Average contact force
    ;end_command
    
    _pc_old_count = 0
    loop _pc_outer (1,10)
        if flt_num <= _pc_remain then
            _pc_rif
            exit
        endif
        _pc_flag_floaters  ; flag and expand floaters
        
        flt_item
        
        if _pc_outer > 1 then  ; skip this check on first pass
            if _pc_n_float >= _pc_old_count ; (got itself into a corner)
                _pc_ncut = math.max(2,_pc_ncut-1)
                flt_def = _pc_ncut
            endif
        endif
        command
            cyc 200 ; get clusters to equilibrium
        endCommand
        
        section
            loop _pc_n (1,100)
                _pc_shrink
                if _debug = 1 then
                    _s_flt = string(_pc_n_float)
                    _s_alt = string(_pc_n_active)
                    oo = io.out(' floaters: '+_s_flt+' active: '+_s_alt)
                endif
                if _pc_n_active = 0
                    _pc_old_count = _pc_n_float
                    exit section
                endif
                command
                    cycle 100
                endCommand
            endLoop
        endSection
        
        _pc_rif
    endLoop
    _pc_rif
end
; ===================================================================
def flt_num
;
; ----- Returns number of floaters (balls with < [flt_def] contacts)
;       in model.
;
; INPUT:  flt_def - balls with < [flt_def] contacts are "floaters"
; OUTPUT: flt_num - number of floaters
;
    flt_num_ = 0
    loop foreach bp ball.list
        md_numcon_bp = map.size(ball.contactmap(bp))
        if md_numcon_bp < flt_def then
            flt_num_ = flt_num_ + 1
        endif
    end_loop
    flt_num = flt_num_
end
; ===================================================================
def flt_item
  ;plot_item
;
; ----- Generates a plotitem for visualizing the floaters.
;
; Visualization Mapping:
;    Floaters are outlined by filled circles that use color(0).
;
    loop foreach bp ball.list
        md_numcon_bp = map.size(ball.contactmap(bp))
        if md_numcon_bp < flt_def then
            usp = user.scalar.create(ball.pos(bp))
            user.scalar.value(usp) = ball.radius(bp)
        endif
    end_loop
end
;
; ===================================================================
; PRIVATE FUNCTIONS
; ===================================================================
;
def _pc_rif
    ; remove inhibit flags
    loop foreach cp contact.list
        contact.inhibit(cp) = false
    endLoop
    
    loop foreach bp ball.list
        caseof global.dim
                ball.fix(bp, 1) = 0
                ball.fix(bp, 2) = 0
                ball.fix(bp, 3) = 0
            case 3
                ball.fix(bp, 1) = 0
                ball.fix(bp, 2) = 0
                ball.fix(bp, 3) = 0
                ball.fix(bp, 4) = 0
                ball.fix(bp, 5) = 0
                ball.fix(bp, 6) = 0
        endcase
    endloop
    ;command
    ;    ball free velocity spin
    ;endcommand
end
; ===================================================================
def _pc_flag_floaters ; Flag floaters & expand
;
    ; ... get mean contact force
    _pc_mcf  = 0.0
    
    loop foreach cp contact.list
        _pc_mcf  = _pc_mcf + math.abs(contact.force.normal(cp))
    endLoop
    _pc_n_cf = map.size(ball.contactmap(bp))
    if _pc_n_cf > 0
        _pc_mcf = _pc_mcf / float(_pc_n_cf)
    endif
    _pc_av_contact_force = _pc_mcf
    _pc_target           = _pc_f_tol * _pc_mcf
    _pc_n_float          = 0
    
    ; ... identify floaters
    loop foreach bp ball.list
        ball.extra(bp, 1) = 0
        caseof global.dim
                ball.vel(bp, 1) = 0.0
                ball.vel(bp, 2) = 0.0
                ball.spin(bp, 3) = 0.0
                ball.fix(bp, 1) = 0
                ball.fix(bp, 2) = 0
                ball.fix(bp, 3) = 0
            case 3
                ball.vel(bp, 1) = 0.0
                ball.vel(bp, 2) = 0.0
                ball.vel(bp, 3) = 0.0
                ball.spin(bp, 1) = 0.0
                ball.spin(bp, 2) = 0.0
                ball.spin(bp, 3) = 0.0
                ball.fix(bp, 1) = 0
                ball.fix(bp, 2) = 0
                ball.fix(bp, 3) = 0
                ball.fix(bp, 4) = 0
                ball.fix(bp, 5) = 0
                ball.fix(bp, 6) = 0
        endcase
        
        _pc_count = map.size(ball.contactmap(bp))
        if _pc_count < _pc_ncut
            ball.extra(bp, 1) = 1
            ball.prop(bp, 'fric')  = 0.0
            ball.radius(bp)   = ball.radius(bp) * _pc_r_mult
            _pc_n_float = _pc_n_float + 1
        else
            caseof global.dim
                case 2
                    ball.fix(bp, 1) = 1
                    ball.fix(bp, 2) = 1
                    ball.fix(bp, 3) = 1
                case 3
                    ball.fix(bp, 1) = 1
                    ball.fix(bp, 2) = 1
                    ball.fix(bp, 3) = 1
                    ball.fix(bp, 4) = 1
                    ball.fix(bp, 5) = 1
                    ball.fix(bp, 6) = 1
            endcase
        endif
    endLoop
;-  -- set inhibit flags ---
    loop foreach cp contact.list
        b1 = contact.end1(cp)
        b2 = contact.end2(cp)
        if type.pointer(b2) = 'ball-ball' then  ; ball-ball contact
            caseof global.dim
                case 2
                    if ball.fix(b1, 3) = 1
                        if ball.fix(b2, 3) = 1
                            contact.inhibit(cp) = true
                        endif
                    endif
                case 3
                    if ball.fix(b1, 4) = 1
                        if ball.fix(b2, 4) = 1
                            contact.inhibit(cp) = true
                        endif
                    endif
            endcase
        endif
    endLoop
end
; ===================================================================
def _pc_shrink ; shrink active balls
    _pc_max_act_force = 0.0
    _pc_n_active      = 0
    loop foreach bp ball.list
        if ball.extra(bp, 1) = 1
            _pc_count = 0
            _pc_sum   = 0.0
            loop foreach cp ball.contactmap(bp)
                _pc_sum   = _pc_sum + contact.force.normal(cp)
            endLoop
            _pc_count = map.size(ball.contactmap(bp))
            
            if _pc_count > 1
                _pc_sum = _pc_sum / float(_pc_count)
                if _pc_sum > _pc_target
                    contact_kn_max = 0.0
                    loop foreach cp ball.contactmap(bp)
                        contact_kn_max = math.max(contact_kn_max, contact.prop(cp, 'kn'))
                    endloop
                    _pc_delta_r  = _pc_relax * (_pc_sum - _pc_hyst * _pc_target) / contact_kn_max ;ball.prop(bp, 'kn')
                    ball.radius(bp)    = ball.radius(bp) - _pc_delta_r
                    _pc_n_active = _pc_n_active + 1
                endif
            endif
        endif
        _pc_max_act_force = math.max(_pc_max_act_force,_pc_sum)
    endLoop
end
; ===================================================================
return
; END OF Filename: flt.FIS